var Lucia = (function () {
  'use strict';

  const DIRECTIVE_PREFIX = 'l-';
  var DIRECTIVE_SHORTHANDS;
  (function (DIRECTIVE_SHORTHANDS) {
      DIRECTIVE_SHORTHANDS["@"] = "on";
      DIRECTIVE_SHORTHANDS[":"] = "bind";
  })(DIRECTIVE_SHORTHANDS || (DIRECTIVE_SHORTHANDS = {}));

  const rawDirectiveSplitRE = () => /:|\./gim;
  const eventDirectivePrefixRE = () => /on|@/gim;
  const parenthesisWrapReplaceRE = () => /\(|\)/gim;
  const hasDirectiveRE = () => {
      return new RegExp(`(${DIRECTIVE_PREFIX}|${Object.keys(DIRECTIVE_SHORTHANDS).join('|')})\\w+`, 'gim');
  };
  const expressionPropRE = (prop) => {
      return new RegExp(`\\b${prop}\\b`, 'gim');
  };

  const formatAcceptableWhitespace = (expression) => {
      return expression.replace(/\s+/gim, ' ').trim();
  };
  const bindDirective = ({ el, name, data, state }) => {
      switch (name.split(':')[1]) {
          case 'class':
              const hydratedClasses = data.compute(state);
              if (typeof hydratedClasses === 'string') {
                  return el.setAttribute('class', formatAcceptableWhitespace(`${el.className} ${hydratedClasses}`));
              }
              else if (hydratedClasses instanceof Array) {
                  return el.setAttribute('class', formatAcceptableWhitespace(`${el.className} ${hydratedClasses.join(' ')}`));
              }
              else {
                  const classes = [];
                  for (const prop in hydratedClasses) {
                      if (hydratedClasses[prop])
                          classes.push(prop);
                  }
                  const removeDynamicClassesRE = new RegExp(`\\b${Object.keys(hydratedClasses).join('|')}\\b`, 'gim');
                  const rawClasses = el.className.replace(removeDynamicClassesRE, '');
                  if (classes.length > 0) {
                      return el.setAttribute('class', formatAcceptableWhitespace(`${rawClasses} ${classes.join(' ')}`));
                  }
                  else if (formatAcceptableWhitespace(el.className).length > 0) {
                      return el.setAttribute('class', formatAcceptableWhitespace(rawClasses));
                  }
                  else {
                      return el.removeAttribute('class');
                  }
              }
          case 'style':
              const hydratedStyles = data.compute(state);
              el.removeAttribute('style');
              for (const prop in hydratedStyles) {
                  el.style[prop] = hydratedStyles[prop];
              }
              break;
          default:
              const hydratedAttributes = data.compute(state);
              if (typeof hydratedAttributes === 'object' && hydratedAttributes !== null) {
                  for (const prop in hydratedAttributes) {
                      if (hydratedAttributes[prop]) {
                          el.setAttribute(prop, hydratedAttributes[prop]);
                      }
                      else {
                          el.removeAttribute(prop);
                      }
                  }
              }
              else if (hydratedAttributes) {
                  el.setAttribute(name.split(':')[1], hydratedAttributes);
              }
              else {
                  el.removeAttribute(name.split(':')[1]);
              }
              break;
      }
  };

  const getCustomProp = (el, prop) => el[prop];
  const setCustomProp = (el, prop, value) => (el[prop] = value);

  const removeDupesFromArray = (array) => {
      return [...new Set(array)];
  };

  const computeExpression = (expression, el, returnable) => {
      let formattedExpression = `with($state){${(returnable !== null && returnable !== void 0 ? returnable : true) ? `return ${expression}` : expression}}`;
      return (state, event) => {
          try {
              const value = state[expression];
              if (value) {
                  return value;
              }
              else {
                  const emit = (name, options, dispatchGlobal = true) => {
                      const event = new CustomEvent(name, options);
                      (dispatchGlobal ? document : el || document).dispatchEvent(event);
                  };
                  return new Function('$state', '$el', '$emit', '$event', formattedExpression)(state, el, emit, event);
              }
          }
          catch (err) {
              console.warn(`Lucia Error: "${err}"\n\nExpression: "${expression}"\nElement:`, el);
          }
      };
  };

  const isListRenderScope = (el) => {
      return el.hasAttribute(`${DIRECTIVE_PREFIX}for`);
  };
  const isUnderListRenderScope = (el) => {
      if (!el.parentElement)
          return false;
      return el.parentElement.hasAttribute(`${DIRECTIVE_PREFIX}for`);
  };
  const createASTNode = (el, state) => {
      const [directives, deps] = collectAndInitDirectives(el, state);
      const hasDirectives = Object.keys(directives).length > 0;
      const hasDepInDirectives = Object.values(directives).some(({ value }) => Object.keys(state).some((prop) => expressionPropRE(prop).test(value)));
      const type = hasDepInDirectives ? 1 : 0;
      if (!hasDirectives)
          return null;
      return { el, deps, directives, type };
  };
  const collectAndInitDirectives = (el, state = {}) => {
      const directives = {};
      const nodeDeps = [];
      for (const { name, value } of el.attributes) {
          const isStateDirective = name === `${DIRECTIVE_PREFIX}state`;
          const hasDirectivePrefix = name.startsWith(DIRECTIVE_PREFIX);
          const hasDirectiveShorthandPrefix = Object.keys(DIRECTIVE_SHORTHANDS).some((shorthand) => name.startsWith(shorthand));
          if (isStateDirective || !(hasDirectivePrefix || hasDirectiveShorthandPrefix))
              continue;
          const depsInFunctions = [];
          const propsInState = Object.keys(state);
          let returnable = true;
          const deps = propsInState.filter((prop) => {
              const hasDep = expressionPropRE(prop).test(String(value));
              if (typeof state[prop] === 'function' && hasDep) {
                  const depsInFunction = propsInState.filter((p) => expressionPropRE(p).test(String(state[prop])));
                  depsInFunctions.push(...depsInFunction);
              }
              return hasDep;
          });
          if (eventDirectivePrefixRE().test(name))
              returnable = false;
          if (name.includes('for') && getCustomProp(el, '__l_for_template') === undefined) {
              setCustomProp(el, '__l_for_template', String(el.innerHTML).trim());
              returnable = false;
          }
          const uniqueCompiledDeps = removeDupesFromArray([...deps, ...depsInFunctions]);
          nodeDeps.push(...uniqueCompiledDeps);
          const directiveData = {
              compute: computeExpression(value, el, returnable),
              deps: uniqueCompiledDeps,
              value,
          };
          const directiveName = hasDirectivePrefix
              ? name.slice(DIRECTIVE_PREFIX.length)
              : `${DIRECTIVE_SHORTHANDS[name[0]]}:${name.slice(1)}`;
          directives[directiveName] = directiveData;
      }
      return [directives, removeDupesFromArray(nodeDeps)];
  };
  const flattenNodeChildren = (rootNode, isListGroup = false, ignoreRootNode = false) => {
      const collection = [];
      const isList = isListRenderScope(rootNode);
      const isUnderList = isUnderListRenderScope(rootNode);
      if (!isListGroup && (isList || isUnderList))
          return collection;
      if (!ignoreRootNode && (!isListGroup || !isList))
          collection.push(rootNode);
      if (isListGroup || (!isList && !isUnderList)) {
          for (const childNode of rootNode.childNodes) {
              if (childNode.nodeType === Node.ELEMENT_NODE) {
                  if (!isListGroup && isListRenderScope(childNode)) {
                      collection.push(childNode);
                  }
                  else {
                      if (childNode.hasAttribute(`${DIRECTIVE_PREFIX}state`))
                          continue;
                      collection.push(...flattenNodeChildren(childNode, isListGroup));
                  }
              }
          }
      }
      return collection;
  };
  const compile = (el, state = {}, ignoreRootNode = false) => {
      if (!el)
          throw new Error('Please provide a HTMLElement');
      const ast = [];
      const isListGroup = getCustomProp(el, '__l') !== undefined && isListRenderScope(el);
      const nodes = flattenNodeChildren(el, isListGroup, ignoreRootNode);
      for (const node of nodes) {
          if (hasDirectiveRE().test(node.outerHTML)) {
              const newASTNode = createASTNode(node, state);
              if (newASTNode)
                  ast.push(newASTNode);
          }
      }
      return ast;
  };

  const render = (ast, directives, state = {}, changedProps = []) => {
      const legalDirectiveNames = Object.keys(directives);
      for (let i = 0; i < ast.length; i++) {
          const node = ast[i];
          if (node.type === -1)
              continue;
          const isStatic = node.type === 0;
          if (isStatic)
              node.type = -1;
          const nodeHasDep = changedProps.some((prop) => node.deps.includes(prop));
          if (!nodeHasDep && !isStatic)
              continue;
          for (const [directiveName, directiveData] of Object.entries(node.directives)) {
              const rawDirectiveName = directiveName.split(/:|\./)[0];
              if (!legalDirectiveNames.includes(rawDirectiveName.toUpperCase()))
                  continue;
              const directiveHasDep = changedProps.some((prop) => directiveData.deps.includes(prop));
              const isStaticDirective = Object.keys(directiveData.deps).length === 0;
              if (directiveHasDep || isStatic || isStaticDirective) {
                  const directiveProps = {
                      el: node.el,
                      name: directiveName,
                      data: directiveData,
                      node,
                      state,
                  };
                  renderDirective(directiveProps, directives);
                  if (isStaticDirective)
                      delete node.directives[directiveName];
              }
          }
      }
  };

  const adjustDeps = (ast, currentDeps, node, directiveName) => {
      const deps = [];
      for (const childNode of ast) {
          deps.push(...childNode.deps);
      }
      const cleanedDeps = removeDupesFromArray([...currentDeps, ...deps]);
      node.deps = cleanedDeps;
      node.directives[directiveName].deps = cleanedDeps;
  };

  const htmlDirective = ({ el, data, state, node }) => {
      var _a;
      node = node;
      const marker = getCustomProp(el, '__l');
      el.innerHTML = (_a = data.compute(state)) !== null && _a !== void 0 ? _a : data.value;
      const ast = compile(el, state, true);
      if (!marker)
          adjustDeps(ast, data.deps, node, 'html');
      render(ast, directives, state, data.deps);
      setCustomProp(el, '__l', true);
  };

  const ifDirective = ({ el, data, state, node }) => {
      var _a, _b;
      node = node;
      const hydratedConditional = !!data.compute(state);
      if (!getCustomProp(node.el, '__l_if_template')) {
          const template = document.createElement('template');
          setCustomProp(template, '__l_if_template', true);
          template.content.appendChild(el.cloneNode(true));
          template.setAttribute(`${DIRECTIVE_PREFIX}if`, data.value);
          el.replaceWith(template);
          node.el = template;
      }
      const hasInserted = getCustomProp(node.el, '__l_has_inserted');
      if (!hydratedConditional && hasInserted) {
          (_a = node.el.nextElementSibling) === null || _a === void 0 ? void 0 : _a.remove();
          setCustomProp(node.el, '__l_has_inserted', false);
      }
      else if (hydratedConditional) {
          if (!hasInserted) {
              const clone = node.el.content.cloneNode(true);
              (_b = node.el.parentElement) === null || _b === void 0 ? void 0 : _b.insertBefore(clone, node.el.nextElementSibling);
              setCustomProp(node.el, '__l_has_inserted', true);
          }
          const nextEl = node.el.nextElementSibling;
          nextEl.removeAttribute(`${DIRECTIVE_PREFIX}if`);
          const ast = compile(nextEl, state);
          const marker = getCustomProp(nextEl, '__l');
          if (!marker)
              adjustDeps(ast, data.deps, node, 'if');
          setCustomProp(nextEl, '__l', true);
          render(ast, directives, state, node.deps);
      }
  };

  const inputCallback = (el, hydratedValue, data, state) => {
      if (el.type === 'checkbox') {
          el.value = String(el.checked);
      }
      const isNumber = typeof hydratedValue === 'number' && !isNaN(el.value);
      const isBoolean = typeof hydratedValue === 'boolean' && (el.value === 'true' || el.value === 'false');
      const isNullish = (hydratedValue === null || hydratedValue === undefined) &&
          (el.value === 'null' || el.value === 'undefined');
      let payload;
      if (isNumber) {
          payload = parseFloat(el.value);
      }
      else if (isBoolean) {
          payload = el.value === 'true';
      }
      else if (isNullish) {
          if (el.value === 'null')
              payload = null;
          else
              payload = undefined;
      }
      else {
          payload = String(el.value);
      }
      state[data.value] = payload;
      return payload;
  };
  const modelDirective = ({ el: awaitingTypecastEl, name, data, state }) => {
      const el = awaitingTypecastEl;
      const hydratedValue = state[data.value];
      const accessor = el.type === 'checkbox' ? 'checked' : 'value';
      if (el[accessor] !== String(hydratedValue)) {
          el[accessor] = hydratedValue;
      }
      if (!getCustomProp(el, '__l_model_registered')) {
          const prop = name.split('.')[1];
          const callback = () => inputCallback(el, hydratedValue, data, state);
          el.addEventListener(prop === 'debounce' ? 'change' : 'input', callback);
          setCustomProp(el, '__l_model_registered', true);
      }
  };

  const onDirective = ({ el, name, data, state }) => {
      const options = {};
      const globalScopeEventProps = ['outside', 'global'];
      if (getCustomProp(el, '__l_on_registered'))
          return;
      const [directiveAndEventName, prop] = name.split('.');
      const eventName = directiveAndEventName.split(':')[1];
      const eventProp = prop || null;
      const target = globalScopeEventProps.includes(String(eventProp)) ? document : el;
      const handler = ($event) => {
          if (eventProp === 'prevent')
              $event.preventDefault();
          if (eventProp === 'stop')
              $event.stopPropagation();
          if (eventProp === 'outside') {
              if (el.contains($event.target))
                  return;
              if (el.offsetWidth < 1 && el.offsetHeight < 1)
                  return;
          }
          data.compute(state, $event);
      };
      options.once = eventProp === 'once';
      options.passive = eventProp === 'passive';
      target.addEventListener(eventName, handler, options);
      setCustomProp(target, '__l_on_registered', true);
  };

  const textDirective = ({ el, data, state }) => {
      var _a;
      el.textContent = (_a = data.compute(state)) !== null && _a !== void 0 ? _a : data.value;
  };

  const forDirective = ({ el, data, state, node }) => {
      node = node;
      const marker = getCustomProp(el, '__l');
      setCustomProp(el, '__l', true);
      const [expression, target] = data.value.split(/\s+(?:in|of)\s+/gim);
      const [item, index] = expression === null || expression === void 0 ? void 0 : expression.trim().replace(parenthesisWrapReplaceRE(), '').split(',');
      const currArray = state[target === null || target === void 0 ? void 0 : target.trim()];
      const ast = compile(el, state);
      let template = getCustomProp(el, '__l_for_template');
      if (el.innerHTML.trim() === template)
          el.innerHTML = '';
      const arrayDiff = (currArray === null || currArray === void 0 ? void 0 : currArray.length) - el.children.length;
      if ((currArray === null || currArray === void 0 ? void 0 : currArray.length) === 0)
          el.innerHTML = '';
      else if (arrayDiff !== 0) {
          for (let i = Math.abs(arrayDiff); i > 0; i--) {
              if (arrayDiff < 0)
                  el.removeChild(el.lastChild);
              else {
                  const tag = template.startsWith('<th')
                      ? 'thead'
                      : template.startsWith('<td') || template.startsWith('<tr')
                          ? 'tbody'
                          : 'div';
                  const temp = document.createElement(tag);
                  let content = template;
                  if (item) {
                      content = content.replace(expressionPropRE(`this\\.${item.trim()}`), `${target}[${currArray.length - i}]`);
                  }
                  if (index) {
                      content = content.replace(expressionPropRE(`this\\.${index.trim()}`), String(currArray.length - i));
                  }
                  temp.innerHTML = content;
                  el.appendChild(temp.firstElementChild);
              }
          }
      }
      if (!marker)
          adjustDeps(ast, data.deps, node, 'for');
      render(marker ? ast : compile(el, state), directives, state, node.deps);
  };

  const directives = {
      BIND: bindDirective,
      HTML: htmlDirective,
      IF: ifDirective,
      MODEL: modelDirective,
      ON: onDirective,
      TEXT: textDirective,
      FOR: forDirective,
  };
  const renderDirective = (props, directives) => {
      const name = props.name.split(rawDirectiveSplitRE())[0];
      directives[name.toUpperCase()](props);
  };

  const arrayEquals = (firstArray, secondArray) => {
      return (firstArray instanceof Array &&
          secondArray instanceof Array &&
          firstArray.length === secondArray.length &&
          firstArray.every((value, i) => value === secondArray[i]));
  };
  const reactive = (state, callback) => {
      const handler = {
          get(target, key) {
              if (typeof target[key] === 'object' && target[key] !== null) {
                  return new Proxy(target[key], handler);
              }
              else {
                  return target[key];
              }
          },
          set(target, key, value) {
              if (typeof state[key] === 'function')
                  return false;
              const hasArrayMutationKey = !isNaN(Number(key)) || key === 'length';
              let props = [];
              if (target instanceof Array && hasArrayMutationKey) {
                  props = Object.keys(state).filter((prop) => arrayEquals(state[prop], target));
              }
              else {
                  if (Object.keys(state).some((prop) => target[prop] === undefined)) {
                      props = Object.keys(state).filter((prop) => typeof state[prop] === 'object');
                  }
                  else {
                      props = [key];
                  }
              }
              target[key] = value;
              callback(props);
              return true;
          },
      };
      return Proxy.revocable(Object.seal(state), handler);
  };

  class Component {
      constructor(state = {}) {
          this.state = state;
          this.directives = {};
      }
      mount(el) {
          const rootEl = typeof el === 'string' ? document.querySelector(el) : el;
          this.ast = compile(rootEl, this.state);
          this.state = reactive(this.state, this.render.bind(this)).proxy;
          this.directives = { ...this.directives, ...directives };
          this.render();
          setCustomProp(rootEl, '__l', this);
          return this.state;
      }
      directive(name, callback) {
          this.directives[name.toUpperCase()] = callback;
      }
      render(props = Object.keys(this.state)) {
          render(this.ast, directives, this.state, props);
      }
  }
  const component = (state) => new Component(state);

  const init = (element = document) => {
      const stateDirective = `${DIRECTIVE_PREFIX}state`;
      const initDirective = `${DIRECTIVE_PREFIX}init`;
      const componentElements = element.querySelectorAll(`[${stateDirective}]`);
      const uninitializedComponents = [...componentElements].filter((el) => getCustomProp(el, '__l') === undefined);
      for (let el of uninitializedComponents) {
          const stateExpression = el.getAttribute(stateDirective);
          const initExpression = el.getAttribute(initDirective);
          const state = computeExpression(`${stateExpression || '{}'}`, el, true)({});
          component(state).mount(el);
          const init = initExpression
              ? computeExpression(`${initExpression}`, el, true)
              : undefined;
          if (init)
              init(state);
      }
  };

  var Lucia = /*#__PURE__*/Object.freeze({
    __proto__: null,
    component: component,
    compile: compile,
    render: render,
    reactive: reactive,
    directives: directives,
    computeExpression: computeExpression,
    init: init
  });

  const DOMReady = () => {
      return new Promise((resolve) => {
          if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', resolve);
          }
          else {
              resolve();
          }
      });
  };
  const init$1 = () => init();
  const start = async () => {
      await DOMReady();
      init$1();
      document.addEventListener('turbolinks:load', init$1);
      document.addEventListener('turbo:load', init$1);
  };
  if (window.__l) {
      window.__l(() => start());
  }
  else {
      start();
  }

  return Lucia;

}());
